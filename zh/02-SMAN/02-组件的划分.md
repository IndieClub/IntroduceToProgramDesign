# 组件的划分

## 什么是组件

什么东西都可以是组件, 连机制,都可以作为组件的一部分.

基础组件: 最常见的就是状态机组件,碰撞体组件,背包组件

资产组件: 信标,血条,控制台 他们是作为一个资产或者机制,
当作组件作为其他机制的一部分

资产组件的存放

-   编辑器中: 一般存放于所在机制

-   文档中: 存放于使用他的模块

-   比如说控制台,控制台在文案中,一般是控制台模块一份,用到控制台的地方一份

-   但是在UE4中,我们就只存放于控制台模块中.

## 组件的划分

MECE原则:

1）问题是否有遗漏（CE）

2）不同问题之间是否有重叠（ME）

比如说: 游戏中,每一个玩家能够对另一个玩家进行投票, 投票数量超过存活玩家一半的,
则被标记为已被驱逐. 驱逐的玩家,将无法进入"驱逐领域".

每一个玩家对玩家进行投票,能够分割为一个组件,
同时由于玩家可以被"标记为已驱逐"那么我们这个组件需要储存: 1. 投票的人, 2.
是否被标记为以驱逐

然后驱逐领域,很明显是一个UBoxComponent

刷新与标记已被驱逐, 很明显是一个机制, 用于统计的

**解耦**

解耦,就是把一个复杂的东西,分成多个步骤.

我们需要详细的描述一下,什么情况,分解出什么样的组件.

-   生命值与如果下雪掉会血

-   生命值组件 存储生命值 ​

-   下雪掉血组件 当下雪的时候,减少生命值组件的血量

生命值与 多种"掉血"情况. 比如说 下雪,下冰雹. 如果这些东西都

-   生命值组件

-   环境掉血 当下雨,下冰堡减少掉血

生命值与 多种掉血: 天气类掉血, 药水类掉血, 属性类掉血(温暖数值过低这类的)

-   生命值组件 储存生命值

-   环境掉血组件 当下酸雨 开始减少生命值

-   药水掉血组件 当中毒,减少生命值

-   属性掉血组件 当饱食度过低,开始减少生命值

一般我们根据系统的复杂度,进行分类, 能够分为一类的, 就不解耦,
尽可能的根据MECE原则分类.

## 组件的编写

文档名字: 组件-\<模块\>-\<机制名字\>-[资产名]

任何东西只需要拥有这三个东西,就可以被认为是组件.

-   属性

-   函数

-   事件(Event) 更新,开启,关闭

如果是"资产组件", 那么你把"机制"改成"机制组件"就可以了

我们的机制,可以作为USubActorComponent的参数,成为组件.
```
# 背包组件
类名: Inventory: UActorComponent
网络通信: 是 //如果是联机需要添加
描述: 用于储存物品堆的, 物品堆,就是某个物品,有多少个
更新速度: 0.1s //有的东西,不需要1秒更新60次

## 伪代码(我用的是C#)

class Inventory: UActorComponent{
[serializable]
List<ItemStack> items 
}
物品的类型
enum Item{
Stone,Wood
}
class ItemStack{
Item item; 物品的类型
byte ammount; 物品的数量
}
## 属性

byte 格子数量: items能够存放几个itemstack
List<ItemStack> 背包内容: 一行,就是一个ItemStack. 有多行,为items变量的内容

文案中编写
`\`\`
格子数量: 1
背包内容:
- 石头 1个
- 木头 1个
`\`\`
## 函数

物品堆 获取背包内容(数字 槽的位置):
- 返回 背包中,槽的位置的物品

## 事件
某事件函数:

## 系统-接口 

某接口-某函数:

```

**基本信息**

```
# 组件
类名: Inventory: UActorComponent
网络通信: 是 //如果是联机需要添加
描述: 用于储存物品堆的, 物品堆,就是某个物品,有多少个
模块: 背包
接口:
- 某接口
事件:
- 某模块:某事件

```
**参考文档(依赖)**

组件的参考文档,只有两种

-   依赖

-   指南/教程

组件一般都是被 机制使用,或者说系统使用, 最多 "使用"其他人的地方,就是依赖了

我们的生命值组件与生命值有一个依赖

**资产列表**

需要注意的是,所需的资产,我们都会添加到机制的资产汇总表.

简单的说,机制资产汇总表记录着所有组件所需要的资产.

其他的,参考机制就可以了

**伪代码**

伪代码最常见的注解有.

**需要注意的是,这里的注解,不是指Unity中的注解**

**这里注解的唯一作用,就是方便你理解下面我们针对数值的定义**

-   ReadOnly 数值

-   在C\#中,这个ReadOnly注解,会导致变量不可以被修改,
    但是我们的变量是可以修改的,只是不可以被地编修改.

-   Range 数值范围的限定

-   Header 属性的介绍

-   Serializable 让其他人知道这个是属性

```
class Inventory: NetworkBehavior{
[serializable]
List<ItemStack> items 
}
物品的类型
enum Item{
Stone,Wood
}
class ItemStack{
Item item; 物品的类型
byte ammount; 物品的数量
}

```

**属性与数值**

属性与数值的唯一区别就是数值是只读的,不可以修改的.

**只读, 针对的是系统策划和地编, 也就是detail视图. 对于程序猿来说,
他只是一个可以被Get,不可以被Set的变量**

**定义**

[readonly] \<类型\> \<字段名字\>: \<介绍\>

\<字段名字\>: 这个变量的名字

\<类型\>: 对应的类型, 如果记不起来返回第一章

[readonly]: 是否是数值

\<介绍\>: 一句话进行介绍
```C++
byte 格子数量:  items能够存放几个itemstack
List<ItemStack> 背包内容: 这个背包的内容
readonly int 当前物品总数量: 这个背包已经存了多少物品
readonly float 当前饱满度: 已经存储数量/最大存储数量  的结果,如果是1,那么就是存满
```

**编写**

参考YAML

\<字段名字\>: \<字段数值\>
```C++
格子数量: 1
背包内容:
- 1 石头
- 1 木头
```
**函数**

函数的作用是,包装一些简单的操作. 会被"事件" 进行使用

**我们不是程序猿,我们不需要细化到逻辑具体的执行,简单的概括一下这个函数干啥.**

**不规范的函数定义是可以的.**

**系统策划定义一个函数的事件所花费的时间,远远大于一个程序猿直接写函数所穿的时间**

比如说,玩家移动需要以下动作,似乎有一些太难了,非常长

1.  Charcatercontroller向右移动

2.  玩家播放动画

3.  玩家播放音效

那么我们可以定义一个“函数”,在逻辑里,你就写 玩家移动(向右边一格)
程序就知道你的意思了.

```
C++
玩家移动(移动方向)：
1. CharacterController 移动至 移动方向
2. 播放动画
3. 播放音效

再逻辑中，你直接写 玩家移动（向右走一格） 就可以了。

```

**事件**

[UE4 Actor事件接口](https://zhuanlan.zhihu.com/p/121044455)

事件,在具体的在编程模式中说明. 我们只会说最主要的几个.

-   更新

-   开启

-   销毁

-   游戏结束

事件-开启: 当组件开启,或者生成时候的事情(BeginPlay)

事件-更新(时间): 当组件更新的时候, 时间指的是 距离上一次更新度过的时间

事件-销毁: 当组件被销毁时候

事件-游戏结束:

**编写**

```
事件-<事件名>(<事件参数>): 
- 逻辑
- 逻辑 
- 逻辑指的是一句话, 话就是逻辑


事件-玩家死亡(玩家)
- 输出字符串 "测试"
- 玩家的积分-1;


```

**系统(接口)**

接口与事件十分相似, 只不过接口是被主动使用的

```
<接口名>-<函数名>:
- 内容

```

```
可攻击接口-受到攻击:
- 生命值-1
```